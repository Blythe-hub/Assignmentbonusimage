"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, <FULL NAME> and <FULL NAME>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1:
UT EID 2:
"""

import sys

# ANSI color blocks for printing
RESET_CHAR = "\x1b[0m"
BLOCK_CHAR = "██"
COLOR_DICT = {
    "black":   "\x1b[40m",
    "red":     "\x1b[41m",
    "green":   "\x1b[42m",
    "yellow":  "\x1b[43m",
    "blue":    "\x1b[44m",
    "magenta": "\x1b[45m",
    "cyan":    "\x1b[46m",
    "white":   "\x1b[47m",
}

def colored(text, color):
    """Wrap the string with the color code."""
    color = color.strip().lower()
    if color not in COLOR_DICT:
        raise ValueError(color + " is not a valid color!")
    return COLOR_DICT[color] + text

def print_block(color):
    """Print a block in the specified color."""
    print(colored(BLOCK_CHAR, color) * 2, end="")

# ---------------------------------- Data Structures ----------------------------------

class Node:
    """
    Represents a node in a singly linked list.

    Instance Variables:
        data: The value or data stored in the node.
        next: The reference to the next node in the linked list (None by default).
    """
    def __init__(self, data, link=None):
        self.data = data
        self.next = link

class StackError(Exception):
    pass

class Stack:
    def __init__(self):
        self._top = None
        self._size = 0

    def peek(self):
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data

    def push(self, item):
        new_node = Node(item, self._top)
        self._top = new_node
        self._size += 1

    def pop(self):
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        removed = self._top.data
        self._top = self._top.next
        self._size -= 1
        return removed

    def is_empty(self):
        return self._top is None

    def size(self):
        return self._size

class QueueError(Exception):
    pass

class Queue:
    def __init__(self):
        self._front = None
        self._rear = None
        self._size = 0

    def dequeue(self):
        if self.is_empty():
            raise QueueError("Dequeue from empty queue.")
        data = self._front.data
        self._front = self._front.next
        if self._front is None:
            self._rear = None
        self._size -= 1
        return data

    def peek(self):
        if self.is_empty():
            raise QueueError("Peek from empty queue.")
        return self._front.data

    def enqueue(self, item):
        new_node = Node(item)
        if self.is_empty():
            self._front = new_node
            self._rear = new_node
        else:
            self._rear.next = new_node
            self._rear = new_node
        self._size += 1

    def is_empty(self):
        return self._size == 0

    def size(self):
        return self._size

class ColoredVertex:
    def __init__(self, index, x, y, color):
        self.index = index
        self.color = color
        self.prev_color = color
        self.x = x
        self.y = y
        self.edges = []
        self.visited = False

    def add_edge(self, vertex_index):
        self.edges.append(vertex_index)

    def visit_and_set_color(self, color):
        self.visited = True
        self.prev_color = self.color
        self.color = color
        print(f"Visited vertex {self.index}")

    def __str__(self):
        return f"index: {self.index}, color: {self.color}, x: {self.x}, y: {self.y}"

class ImageGraph:
    def __init__(self, image_size):
        self.vertices = []
        self.image_size = image_size

    def print_image(self):
        img = [["black" for _ in range(self.image_size)] for _ in range(self.image_size)]
        for vertex in self.vertices:
            img[vertex.y][vertex.x] = vertex.color
        for row in img:
            for pixel in row:
                print_block(pixel)
            print()
        print(RESET_CHAR)

    def reset_visited(self):
        for v in self.vertices:
            v.visited = False

    def create_adjacency_matrix(self):
        n = len(self.vertices)
        matrix = [[0]*n for _ in range(n)]
        for v in self.vertices:
            for j in v.edges:
                matrix[v.index][j] = 1
        return matrix

    def bfs(self, start_index, color):
        self.reset_visited()
        print("Starting BFS; initial state:")
        self.print_image()
        orig_color = self.vertices[start_index].color
        q = Queue()
        self.vertices[start_index].visit_and_set_color(color)
        q.enqueue(start_index)
        while not q.is_empty():
            cur = q.dequeue()
            for nbr_idx in self.vertices[cur].edges:
                nbr = self.vertices[nbr_idx]
                if not nbr.visited and nbr.color == orig_color:
                    nbr.visit_and_set_color(color)
                    q.enqueue(nbr_idx)

    def dfs(self, start_index, color):
        self.reset_visited()
        print("Starting DFS; initial state:")
        self.print_image()
        orig_color = self.vertices[start_index].color
        st = Stack()
        st.push(start_index)
        while not st.is_empty():
            cur = st.pop()
            v = self.vertices[cur]
            if not v.visited and v.color == orig_color:
                v.visit_and_set_color(color)
                for nbr_idx in reversed(v.edges):
                    if not self.vertices[nbr_idx].visited:
                        st.push(nbr_idx)

def create_graph(data):
    """
    Creates an ImageGraph object from the given input data and parses
    the starting position and search color.

    pre: data is the entire inputted data as a single string.
    post: returns a tuple (graph, start_index, new_color).
    """
    lines = [l.strip() for l in data.splitlines() if l.strip()]
    image_size = int(lines[0])

    num_vertices = int(lines[1])
    g = ImageGraph(image_size)
    idx = 2
    for i in range(num_vertices):
        x, y, col = [s.strip() for s in lines[idx].split(",")]
        g.vertices.append(ColoredVertex(i, int(x), int(y), col))
        idx += 1

    num_edges = int(lines[idx]); idx += 1
    for _ in range(num_edges):
        a, b = [int(s) for s in lines[idx].split(",")]
        g.vertices[a].add_edge(b)
        g.vertices[b].add_edge(a)
        idx += 1

    start, new_col = [s.strip() for s in lines[idx].split(",")]
    return g, int(start), new_col

def main():
    """
    The main function that drives the program execution.
    """
    if len(sys.argv) < 2:
        print("Usage: python graph.py <input_file>")
        sys.exit(1)
    with open(sys.argv[1], 'r') as f:
        data = f.read()
    graph, start, color = create_graph(data)

    # adjacency matrix
    mat = graph.create_adjacency_matrix()
    print("[")
    for row in mat:
        print("    " + str(row))
    print("]")

    # BFS fill
    graph.bfs(start, color)

    # rebuild graph for fresh DFS
    graph, start, color = create_graph(data)
    graph.dfs(start, color)

if __name__ == "__main__":
    main()
